import { FC, useLayoutEffect, useState } from "react";

const HookUseLayoutEffect: FC = () => {
  const [value, setValue] = useState("initialValue");
  useLayoutEffect(() => {
    setValue("afterUseLayoutEffect");
  }, []);

  return (
    <div>
      <b>Value:</b> {value}
      <div>
        <h3>Описание:</h3>
        <div>
          Логика использования useLayoutEffect - такаяже как и у useEffect, но
          он выполняется ещё до загрузки каркаса приложения.
        </div>
        <h3>
          Практическое применение - такоеже как и у useEffect - SideEffect-ов:
        </h3>
        <h3>Также важно производить отписку от событий</h3>
        <h3>Так в чем же различия:</h3>
        <div style={{ maxWidth: "70%", margin: "12px auto" }}>
          <b>Технические различия:</b> <br />
          <i>
            Время выполнения: <br />
          </i>
          Основное различие между ними заключается в том, когда они выполняются.
          useEffect выполняется после того, как виртуальный DOM обновится и
          изменения были визуально отображены на экране. В то время как
          useLayoutEffect выполняется перед тем, как браузер обновит экран, так
          что он блокирует обновление экрана до того, как эффект завершится.
          <br />
          <i>
            Синхронность: <br />
          </i>
          Из-за того, что useLayoutEffect блокирует обновление экрана, он может
          вызвать задержки в рендеринге и взаимодействии, особенно если код
          внутри него занимает много времени. В то время как useEffect более
          асинхронный и обычно не влияет на производительность.
        </div>
        <div style={{ maxWidth: "70%", margin: "12px auto" }}>
          <b>Практические различия:</b> <br />
          <i>
            Синхронизация с браузером: <br />
          </i>
          Если вам нужно выполнить какие-либо манипуляции с DOM, которые могут
          повлиять на браузерный макет (например, изменения, влияющие на
          геометрию элементов), то useLayoutEffect может быть более подходящим
          выбором, так как он гарантирует, что эффекты будут выполнены перед
          тем, как браузер обновит экран.
          <br />
          <i>
            Асинхронные операции: <br />
          </i>
          Если вы работаете с асинхронными операциями, такими как сетевые
          запросы, useEffect может быть предпочтительным вариантом, так как он
          не блокирует обновление экрана, что позволяет вашему интерфейсу
          оставаться более отзывчивым.
        </div>
      </div>
    </div>
  );
};

export default HookUseLayoutEffect;
